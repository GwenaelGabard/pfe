"""Finite-element mesh"""
import numpy as np
import gmsh
from scipy.spatial import KDTree
import matplotlib.pyplot as plt
from pfe.geometry import Line3_2D, Triangle6_2D, Point


from_type = {9: Triangle6_2D, 8: Line3_2D, 15: Point}


class ElementType:
    """A type of elements (T6, L3, etc)

    This class contains a list of elements of the same type.
    It includes informations about this particular type of elements such as type id, name, number
    of dimensions, etc.
    It also contains the list of nodes defining each element of this type as well as the tag for
    each element.
    """

    def __init__(self, id):
        """Constructor

        :param id: The number identifying the type of elements
        :type id: An integer
        """
        self.id = id
        (
            self.name,
            self.num_dim,
            self.order,
            self.num_nodes,
            _,
            _,
        ) = gmsh.model.mesh.getElementProperties(id)
        self.nodes = None
        self.tags = None


class Probes:
    """A group of probes on a given mesh

    An instance of this class is generated by the function Mesh.locate_points.
    This is used to store information to subsequently evaluate a field interpolated on the mesh.
    It contains a reference to the mesh, the physical coordinates of the probes, the elements
    containing the probes and the reference coordinates of the probes in each element.
    """

    def __init__(self):
        """Constructor"""
        self.mesh = None
        self.coordinates = None
        self.elements = None
        self.positions = None


class Mesh:
    """
    Mesh
    ====

    The class represents a finite-element mesh which is the combination of the following things:

    * A list of node coordinates (either in 1D, 2D or 3D)
    * A collections of elements, potentially of different types (linear triangle, quadratic lines,
    linear tetrahedra, etc).
    * Connections between elements, i.e. who are the elements neighboring a given element.
    * Groups of elements to assign physical meaning such as boundary conditions.

    This class can also represent a subset of an existing mesh, using the ``group`` method.

    This class only has information about the geometry and doesn't provide information about the
    physics of the problem.

    Meshes can be loaded from .msh files generated byb GMSH.
    """

    def __init__(self, filename=None, num_dim=3):
        """Constructor

        :param filename: The name of the msh file containing the mesh, defaults to None
        :type filename: A string, optional
        :param num_dim: The number of spatial dimensions, defaults to 3
        :type num_dim: A positive integer (1, 2, or 3), optional
        """
        self.storage = []
        self.coordinates = None
        self.num_dim = num_dim
        self.groups = []
        self.origin = None
        self.subset = None
        self.node_tags = None
        self.origin_to_sub = None
        if filename:
            self.from_msh(filename)

    def from_msh(self, filename):
        """Read the mesh from an msh file

        :param filename: The name of the msh file
        :type filename: A string
        """
        print("Opening mesh {}".format(filename))
        gmsh.initialize()
        gmsh.option.setNumber("General.Terminal", 0)

        # Open the input file
        gmsh.open(filename)

        # Read the nodes
        tags, coordinates, _ = gmsh.model.mesh.getNodes()
        num_nodes = len(tags)
        coordinates = coordinates.reshape(num_nodes, 3)
        self.coordinates = coordinates[:, 0 : self.num_dim].T
        print("Reading {} nodes".format(self.coordinates.shape[1]))

        # Read all the elements
        types, tags, elements = gmsh.model.mesh.getElements()

        # Create the element by types
        print("Reading elements...")
        for n, t in enumerate(types):
            e = ElementType(t)
            e.tags = tags[n] - 1
            e.nodes = elements[n].reshape(len(e.tags), e.num_nodes) - 1
            self.storage.append(e)
        for t in self.storage:
            print("* {} elements {}".format(len(t.tags), t.name))

        max_tag = 0
        for n, s in enumerate(self.storage):
            max_tag = max(max_tag, np.max(s.tags))
        self.tag_to_storage = np.zeros((int(max_tag) + 1,), dtype="uint32")
        self.tag_to_position = np.zeros((int(max_tag) + 1,), dtype="uint64")
        for n, s in enumerate(self.storage):
            self.tag_to_storage[s.tags] = n
            self.tag_to_position[s.tags] = np.arange(len(s.tags))

        print("Reading groups...")
        entities = gmsh.model.getEntities()
        self.groups = [None] * len(entities)
        for e in entities:
            dim = e[0]
            tag = e[1]
            group = gmsh.model.getPhysicalGroupsForEntity(dim, tag)
            if group.size > 0:
                group_number = group[0]
                _, elemTags, _ = gmsh.model.mesh.getElements(dim, tag)
                elemTags = np.array(elemTags, dtype="uint64").flatten() - 1
                if self.groups[group_number] is None:
                    self.groups[group_number] = elemTags
                else:
                    self.groups[group_number] = np.concatenate(
                        (self.groups[group_number], elemTags)
                    ).flatten()
        for n, g in enumerate(self.groups):
            if g is not None:
                print("* group {}: {} elements".format(n, g.shape[0]))

        self.create_node_tags()

        gmsh.clear()
        gmsh.finalize()

    def group(self, groups):
        """Create a mesh representing a subset of the mesh

        :param groups: The number or numbers of the group(s) defining the mesh subset
        :type groups: A positive integer or a sequence of positive integers
        :return: A mesh with only the subset of the original mesh
        :rtype: An instance of the Mesh class
        """
        m = Mesh()
        m.num_dim = self.num_dim
        m.origin = self
        m.subset = np.array([], dtype="uint64")
        if isinstance(groups, (list, tuple)):
            for g in groups:
                m.subset = np.append(m.subset, self.groups[g])
        else:
            m.subset = np.append(m.subset, self.groups[groups])
        m.create_node_tags()
        return m

    def element_node_tags(self, tag):
        """The node tags of a given element

        :param tag: The element tag
        :type tag: A positive integer
        :return: The nodes representing the given element
        :rtype: A sequence of positive integers
        """
        if self.origin:
            temp = self.origin.element_node_tags(tag)
            return self.origin_to_sub[temp]
        temp = self.storage[self.tag_to_storage[tag]].nodes[
            self.tag_to_position[tag], :
        ]
        return temp

    def create_node_tags(self):
        """Create a internal list of the nodes involves in a mesh subset"""
        if self.origin:
            N = []
            for tag in self.subset:
                N.append(self.origin.element_node_tags(tag))
            self.node_tags = np.unique(np.concatenate(N))
            self.origin_to_sub = np.full(self.origin.num_nodes(), -1)
            self.origin_to_sub[self.node_tags] = np.arange(self.num_nodes())
        else:
            self.node_tags = np.arange(self.coordinates.shape[1])

    def num_nodes(self):
        """The number of nodes in the mesh

        :return: The number of nodes
        :rtype: A positive integer
        """
        return len(self.node_tags)

    def nodes(self):
        """The coordinates of the nodes

        :return: The coordinates of the nodes involved in the mesh
        :rtype: A Numpy array
        """
        if self.origin:
            return self.origin.coordinates[:, self.node_tags]
        return self.coordinates

    def get_elements(self, dim):
        """Get the tags of all elements on a given dimension

        :param dim: The dimension of the element requested
        :type dim: A positive integer (0, 1, 2 or 3)
        :return: The list of element tags
        :rtype: A Numpy array of positive integers
        """
        tags = []
        if self.origin:
            for tag in self.subset:
                if self.origin.storage[self.origin.tag_to_storage[tag]].num_dim == dim:
                    tags.append(tag)
        else:
            for s in self.storage:
                if s.num_dim == dim:
                    tags.append(s.tags)
            tags = np.concatenate(tags)
        return tags

    def element_type(self, tag):
        """The type of a given element

        :param tag: The tag of the element
        :type tag: A positive integer
        :return: The type of the given element
        :rtype: A positive integer
        """
        if self.origin:
            return self.origin.element_type(tag)
        return self.storage[self.tag_to_storage[tag]].id

    def element_nodes(self, tag):
        """The coordinates of the nodes involved in a given element

        :param tag: The tag of the element
        :type tag: A positive integer
        :return: The coordinates of the nodes involved in this element
        :rtype: A Numpy array
        """
        if self.origin:
            self.origin.element_nodes(tag)
        return self.coordinates[:, self.element_node_tags(tag)]

    def element_geometry(self, tag):
        """A geometry object for the given element

        :param tag: The tag of the element
        :type tag: A positive integer
        :return: The geometry of the element
        :rtype: An instance of the class from pfe.geometry (such as Line3_2D, or Triangle6_2D)
        """
        if self.origin:
            return self.origin.element_geometry(tag)
        nodes = self.element_nodes(tag)
        g = from_type[self.element_type(tag)](nodes)
        return g

    def locate_points(self, points):
        """Locate a group of points on the mesh.

        This involves identifying the element containing each points and computing the reference
        coordinates of the point within the element.
        If a point is not within the mesh, then None is used to used.

        :param points: The coordinates of the points to locate
        :type points: A Numpy array
        :return: The containing element and reference coordinates for each point
        :rtype: An instance of the Probes class
        """
        num_points = points.shape[1]
        p = self.nodes().T
        _, n = KDTree(p).query(points.T)
        nodes = self.node_tags[n]
        elements = np.full((num_points,), -1, dtype=np.int32)
        positions = [None] * num_points
        for i in range(num_points):
            for s in self.storage:
                n = np.where(s.nodes == nodes[i])[0]
                tags = s.tags[n]
                for tag in tags:
                    uvw = self.element_geometry(tag).locate_point(points[:, i])
                    if uvw is not None:
                        elements[i] = tag
                        positions[i] = uvw
                        break
        probes = Probes()
        probes.mesh = self
        probes.coordinates = points
        probes.elements = elements
        probes.positions = positions
        return probes

    def plot(self):
        for s in self.storage:
            n = np.hstack((s.nodes, s.nodes[:,0][:,None])).T
            plt.plot(self.coordinates[0,n], self.coordinates[1,n], 'k-', linewidth=0.1)
